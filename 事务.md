# 											TCL

**Transaction   Control   Language   ---->事务控制语言**

事务：由一个或者一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行，每个sql语句是互相依赖的、如果单元中某条sql语句一旦执行失败或者产生错误，整个单元将会回滚，所有受到影响的数据将返回到事务开始以前的状态。如果执行成功，则执行成功、

案例：转账			张三丰  1000		郭襄      1000

```
update 表 set 张三丰的余额=500 where name=‘ 张三丰’
意外.....
update 表 set  郭襄的余额=1500 where name=‘ 郭襄’
```

- 查看MySQL支持的存储引擎：`show engines;`
- 存储引擎：在mysql中的数据用各种不同的技术存储在文件（或者内存）中，又叫做表结构

**事务的ACID属性：原子性，一致性，隔离性，持久性**--------->事务的特性

1. **原子性（Atomicity）：**

   一个事务不可再分，事务中的操作要么都发生，要么都不发生。

2. **一致性（Consistency）：**

   ​	一个事务执行会使数据从一个一致性状态变换到另一个一致性状态。

3. **隔离性（lsolation）：**

   指一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。关键还是要看隔离级别

4. **持久性（Durability）：**

   持久性是指一个事务一旦被提交，对数据库中的数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。



事务的创建：

隐式事务：事务没有明显的开启和结束的标记

比如  insert 、update、delete语句

```
//查看变量
mysql> show variables like 'autocommit';(自动提交---->默认的值为ON开启状态)
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | ON    |
+---------------+-------+
1 row in set
```

显式事务：事务具有明显的开启和结束的标记

**前提：必须先设置自动提交功能为禁用**

**set  autocommit=0;**

```
mysql> set  autocommit=0;
Query OK, 0 rows affected
//执行成功，并且将自动提交功能设置成功为关闭状态
mysql> show variables like 'autocommit';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | OFF   |
+---------------+-------+
1 row in set
```

关了仅对当前事务有效，下次事务还需要重新设置。

```
步骤1：开启事务
	set autocommit=0;
	start transaction;可选的
步骤2：编写事务中的sql语句（仅针对select、insert、update、delete）
	语句1，
	语句2，
	....
步骤3：结束事务
    commit;结束事务
    rollback;回滚事务
```

```
演示事务的使用步骤：具体例子

#开启事务
set autocommit=0;
start TRANSACTION;
#编写一组事务的语句
update account set balance =500 where username='张无忌';
update account set balance =1500 where username='赵敏';
#结束事务
commit;

SELECT * from account;
```

对于同时运行的多个事务，当这些事务访问的是数据库中相同的数据时，如果没有采取必要的隔离机制，就会导致各种并发问题：（类似线程的安全问题，可以通过加锁解决）

**脏读：**对于两个事务T1、T2、T1读取了已经被T2**更新**的但是**没有提交**的字段之后，若T2回滚，T1读取的内容就是临时且无效的。 

**不可重复读：**对于两个事务T1、T2，T1读取了一个字段，然后T2**更新**了该字段之后，T1再次读取哦你跟一个字段，值就不同了。

**幻读：**对于两个事务T1、T2，T1从一个表中读取了一个字段，然后T2在表中**插入**了一些新的行，如果T1再次读取同一张表，就会多处几行。

**数据库事务的隔离性：**

​		数据系统必须具有隔离并发运行各个事务的能力，使它们不会互相影响，避免各种并发问题。（设置隔离级别）

**隔离级别：**

​		一个事务与其他事务隔离的程度称为隔离级别，数据库规定了多种事务隔离级别，不同隔离级对应不同的干扰程度，隔离级别越高，数据一致性就越好，但并发性越弱。

Mysql支持四种事务隔离级别默认的是`repeatable read`

- **read uncommitted :（读未提交数据）**允许事务读取未被其他事务提交的变更，脏读，不可重复读和幻读的问题**都会出现**
- **read commited：（读已提交数据）**只允许事务读取已经被其他事务提交的变更，可以**避免脏读**，但不可重复读和幻读问题仍然可能出现。
- **repeatable read:（可重复读）**确保事务可以多次从一个字段中读取相同的值，在这个事务持续期间，禁止其他事务对这个字段进行更新，**可以避免脏读和不可重复读**，但幻读的问题依然存在。
- **serializable：(串行化)**确保事务可以从一个表中读取相同的行，在这个事务持续期间，禁止其他事务对该表执行插入，更新和删除操作，**所有并发问题都可以避免**，但性能十分低下。

**查看隔离级别：**

1.查看当前会话隔离级别

```
select @@transaction_isolation;
```

2.查看系统当前隔离级别

```
select @@global.transaction_isolation;
```

```
mysql> select @@global.transaction_isolation;
+--------------------------------+
| @@global.transaction_isolation |
+--------------------------------+
| REPEATABLE-READ                |
+--------------------------------+
1 row in set (0.00 sec)
```

设置当前MySQL连接的隔离级别：`set session transaction isolation level read uncommitted;`

设置数据库系统的全局的隔离级别：`set global transaction isolation level read committed;`

修改字符集：`set names gbk;`

**注意：设置的隔离级别，仅对当前有用。**

![]()



# 											锁：

**锁是计算机协调多个进程或线程并发访问某一资源的机制**：保证数据并发访问的一致性、有效性

**表级锁：**开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。 
**行级锁：**开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。 
**页面锁：**开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般 